# Format String Attack Lab
- the `printf()` function in C is used to print out a string according to a format, its first argument is called *format* string, the format string uses placeholders marked by the `%` character, there are also other functions that use format string, `sprintf()`, `fprintf()`, `scanf()`
- some programs allow users to provide the entire or part of the contents in a format string, if such contents are not sanitized, attacker can use this opportunity to get the program to run arbitrary code, this problem is called **format string vulnerability**

- topics
    - format string vulnerability
    - code injection
    - stack layout
    - shellcode
    - reverse shell

- lab environment: `SEED Ubuntu 20.04 VM`

- the stack layout when call `printf("a=%d, b=%d", a, b)`
    ```
    High Memory Addresses
    |          +--------------------------+     
    |          |           ...            |
    |          +--------------------------+
    |          |            b             |
    |          |--------------------------| 
    |          |            a             |
    |          |--------------------------| 
    |          | address of format string |
    |          |--------------------------|
    |          |      return address      |
    |          |--------------------------|
    |          |     previous ebp/rbp     |
    |          |--------------------------|
    |          |           ...            |    
    |          +--------------------------+
    |          |       Unused Space       |
    |          +--------------------------+
    Low Memory Addresses
    ```
    - if we don't provide enough parameters, e.g., `printf("a=%d, b=%d", a)`, it will fetch the content from the position where `b` is supposed to be

## Setup
- turn off Address Space Layout Randomization:`sudo sysctl -w kernel.randomize_va_space=0` 
- compile server code (in the directory `Labsetup/server-code`)
    ```
    $ make
    [here will be a warning message]
    $ make install
    ```
- the warning message is generated by a countermeasure implemented in `gcc`, we can ignore it for now
- `-z execstack` option should be used in the compilation, for simplicity, non-executable stack countermeasure can be defeated using return-to-libc, there is a separate lab for return-to-libc

## Task 1: Crashing the Program
- target server `10.9.0.5`
- send a message to the server, we can see some information printed by the target container
    ```
    $ echo hello | nc 10.9.0.5 9090
    (Press Ctrl+C)
    ```
    ```
    server-10.9.0.5 | Got a connection from 10.9.0.1
    server-10.9.0.5 | Starting format
    server-10.9.0.5 | The input buffer's address:    0xffffd240
    server-10.9.0.5 | The secret message's address:  0x080b4008
    server-10.9.0.5 | The target variable's address: 0x080e5068
    server-10.9.0.5 | Waiting for user input ......
    server-10.9.0.5 | Received 6 bytes.
    server-10.9.0.5 | Frame Pointer (inside myprintf):      0xffffd168
    server-10.9.0.5 | The target variable's value (before): 0x11223344
    server-10.9.0.5 | hello
    server-10.9.0.5 | The target variable's value (after):  0x11223344
    server-10.9.0.5 | (^_^)(^_^) Returned properly (^_^)(^_^)
    ```
- our goal for this task is to provide an input that makes the program crash (i.e., "Returned properly" is not printed out)
    - if we try `echo %d | nc 10.9.0.5 9090`, a value will be printed out
        ```
        server-10.9.0.5 | The target variable's value (before): 0x11223344
        287454020   <--- where does this come from
        server-10.9.0.5 | The target variable's value (after): 0x11223344
        ```
    - but if we use `%x` instead, this value becomes `11223344`, i.e., the target variable's value, the reason is that before we call `printf(msg)`, the program prints the value of `target`, and after the previous `printf` returns, its parameter `target` remains in the stack, the only problem is that when call `printf("The target variable's value (before): %x", target)`, it first pushes `target`, then the format string, so when it returns, the top of the stack should be the format string, not `target`, to figure out why `printf("%x")` skips the address of `"The target variable's value (before): %x"` and prints out `target`, I wrote a simple program and debugged it
        - core code of the program
            ```
            char buffer[500];
            scanf("%s", buffer);
            printf("%d", 8);
            printf(buffer);
            ```
        - check the printout, `printf(buffer)` prints out `8`, this is exactly what we expect
            ```
            $ gcc -m32 -o test test.c
            $ ./test
            8   <---- input for scanf()
            88  <---- output
            ```
        - use `gdb -q ./test` to debug it and see what happens
        
    - try `echo %s | nc 10.9.0.5 9090`
        ```
        ...
        server-10.9.0.5 | The target variable's value (before): 0x11223344
        (no more info printed out)
        ```
        - the program is crashed
## Task 2: Printing Out the Server Program's Memory
- target server `10.9.0.5`
- the objective of this task is to get the server to print out some data from its memory, the data will be printed out on the server side, so the attack cannot see it, but the technique used in this task will be essential for the subsequent tasks

### Task 2.A: Stack Data
- how many `%x` format specifiers do you need to get the program to print out the first four bytes of your input

### Task 2.B: Heap Data
- there is a secret message (a string) stored in the heap area, and the server prints out its address, our objective is to print out this secrete message
    - we need to place the address (in the binary form) of the secret message in the format string


## Task 3: Modifying the Server Program's Memory

## Task 4: Inject Malicious Code into the Server Program

## Task 5: Attacking the 64-bit Server Program

## Task 6: Fixing the Problem